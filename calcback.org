#+TITLE: Calcback
#+AUTHOR: Nikolai Weidt
#+Email: weidtn@gmail.com
#+PROPERTY: header-args:python :session *python*
#+PROPERTY: cache yes
#+PROPERTY: latexpreview inlineimages
#+PROPERTY: attr_html:width 600px
#+options: toc:2
#+latex_header: \usepackage{float}
#+PANDOC_OPTIONS: pdf-engine:xelatex


* What is this?
This is a script to get the complex refractive index $n = n * ik$ from the ellipsometric parameters $\Delta$ and $\Psi$ I got from a simulation.
The result for 300nm SiO_2 should look like this:

#+CAPTION: Refractive index should look like this
#+NAME: sio2
#+attr_latex: :width \textwidth
#+attr_html: :width 500
#+attr_org: :width 500
[[./RefractiveIndexSiO2.png]]
* List of Todos:

** TODO Write a loop for all wavelengths after it works for one.
** TODO Then take even more wavelengths (rows)
* Imports:
#+BEGIN_SRC python :results output silent :tangle yes
  import numpy as np
  import matplotlib
  matplotlib.use('Agg')
  import matplotlib.pyplot as plt
#+END_SRC 

* Defining some variables:
Defining some variables for later use:

#+BEGIN_SRC python :results output silent :tangle yes
  CSVFILE = "head300nmSiO2.csv"  # head = only 10 rows of data
  phi_i = 70 * np.pi / 180  # converting incident angle from deg (first number) to rad
  d_L = 300  # thickness of layer in nm
  n_air = 1  # refractive index of air
  rerange = 5  # upper limit for real part
  imrange = 1  # upper limit for imaginary part
  i = 0  # only look at one wavelength (row in csv)
#+END_SRC

* Read .csv-file:
Read the values into a two dimensional numpy array as [[lambda,Psi,Delta,n_S, k_S],...] (Skip columns 3 and 4)
  
#+BEGIN_SRC python :results output silent :tangle yes
csv = np.loadtxt(CSVFILE, usecols=(0,1,2,5,6),  delimiter=",", skiprows=1)
#+END_SRC

:DEBUG:
The array looks like this:
#+BEGIN_SRC python :results value verbatim :exports both
csv
#+END_SRC

#+RESULTS:
: [[300.          55.2217535   84.37228319   2.6726       3.0375    ]
:  [303.          50.11187439  93.3085011    2.7346       3.0381    ]
:  [306.          46.35824553  98.43681392   2.7967       3.0368    ]
:  [309.          43.50539341 101.18051798   2.8588       3.0334    ]
:  [312.          41.29392865 102.19236832   2.9206       3.0279    ]
:  [315.          39.48751217 101.93002      2.9822       3.0205    ]
:  [318.          37.90308303 100.64846104   3.0435       3.0109    ]
:  [321.          36.47640803  98.54577151   3.1042       2.9994    ]
:  [324.          35.12615859  95.72242205   3.1644       2.9858    ]]
:END:

* Calculate \rho
** Create a matrix containing every possible refractive index (n+ik):

Change the last number in the "linspaces" to adjust the resolution.

#+BEGIN_SRC python :results silent :tangle yes
  lsp_re = np.linspace(1, rerange, 1001)
  lsp_im = np.linspace(0.01, imrange, 1001)
  re, im = np.meshgrid (lsp_re, lsp_im, copy=False)
  n_L = 1j * np.round(im,6) + np.round(re,6)
  n_L = n_L.flatten() # create onedimensional array
#+END_SRC

:DEBUG:
This gives the following matrix:
#+BEGIN_SRC python :results value verbatim :exports both :tangle no
  n_L
#+END_SRC

#+RESULTS:
: [1.   +0.01j 1.004+0.01j 1.008+0.01j ... 4.992+1.j   4.996+1.j
:  5.   +1.j  ]

:END:

** Calculate \rho: 
*** First we define some functions:
**** Snell's Law to calculate the refractive angles:
Phi is the incident angle for the layer, n1 and n2 are refractive indices of first and second medium. Returns the angle of refraction.

#+CAPTION: Snell's Law
#+NAME: fig:snell
#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 500
#+ATTR_LATEX: :width \textwidth
#+ATTR_LATEX: :placement [H]
[[./snell.jpg]]
#+BEGIN_SRC python :results silent :tangle yes
  def snell(phi, n1, n2):
    """Calculates the refractive angle, parameters are incident angle phi, refractive index of first medium n1 and of second medium n2"""
    phi_ref = np.arcsin((n1/n2)*np.sin(phi))
    return phi_ref
#+END_SRC   


**** Calculate r_p and r_s with Fresnel equations:
#+BEGIN_SRC python :results silent :tangle yes
  def fresnel(n1, phi1, n2, phi2):
      """Takes refractive indices and angles of two layers to calculate the amplitude reflection coefficients"""
      rs = (n1 * np.cos(phi1) - n2 * np.cos(phi2)) / (n1 * np.cos(phi1) + n2 * np.cos(phi2))
      rp = (n2 * np.cos(phi1) - n1 * np.cos(phi2)) / (n2 * np.cos(phi1) + n1 * np.cos(phi2))
      return rs, rp
#+END_SRC


**** Calculate \rho for the layer with eq. 5.2 in Spectroscopic Ellipsometry citenum:fujiwara2009spectroscopic:
#+BEGIN_SRC python :results silent :tangle yes
  def calc_rho(rs_al, rp_al, rs_ls, rp_ls, d, n, phi, lambda_vac, returnbeta=False):
      beta = 2 * np.pi * d * n * np.cos(phi) / lambda_vac
      rp_L = (rp_al + rp_ls * np.exp(-2*1j*beta)) / (1 + rp_al * rp_ls * np.exp(-2 * 1j * beta))
      rs_L = (rs_al + rs_ls * np.exp(-2*1j*beta)) / (1 + rs_al * rs_ls * np.exp(-2 * 1j * beta))
      rho_L = rp_L / rs_L
      return rho_L
#+END_SRC


*** Then we call these functions one after another to calculate \rho:
Get refractive index of the substrate (n_S) and lambda from the csv:
#+BEGIN_SRC python :results output silent :tangle yes
  lambda_vac = csv[i][0]
  n_S = (csv[i][3] + 1j * csv[i][4])
#+END_SRC

Then call the above defined functions
#+BEGIN_SRC python :results output :tangle yes
  phi_L = snell(phi_i, n_air, n_L)
  phi_S = snell(phi_L, n_L, n_S)
  # Fresnel equations:
  # air/layer:
  rs_al, rp_al = fresnel(n_air, phi_i, n_L, phi_L)
  # layer/substrate:
  rs_ls, rp_ls = fresnel(n_L, phi_L, n_S, phi_S)

  rho_L = calc_rho(rs_al, rp_al, rs_ls, rp_ls, d_L, n_L, phi_L, lambda_vac)
#+END_SRC

#+RESULTS:

:DEBUG:
#+BEGIN_SRC python :results value scalar :tangle no :exports none
  # lambda_vac
  # phi_L
  # phi_S
  # rs_al
  # rp_al
  # rs_ls
  # rp_ls
  type(rho_L)
  # csv[:,0] # list of lambdas
#+END_SRC

#+RESULTS:
: <class 'numpy.ndarray'>

:END:


*** Identify the best fitting rho with \rho = tan(\psi) * e^i\Delta :

#+BEGIN_SRC python :results output :exports both :tangle yes
  # psi is in our csv-file at index 1, delta at index 2 at row "i" for lambda
  psi = csv[i][1] * (np.pi/180)
  delta = csv[i][2] * (np.pi/180)
  rho_giv = np.tan(psi) * np.exp(1j * delta)
  diff = abs(rho_giv - rho_L)  # magnitude of complex number
  idx = np.argmin(diff)  # index of the minimum
  minimum = diff[idx]
  n = n_L[idx]
  print("At lambda = ", lambda_vac)
  print("the layer has the refractive index n_L = " , n)
#+END_SRC

#+RESULTS:
: At lambda =  300.0
: the layer has the refractive index n_L =  (1.504+0.10108j)

* Plot some things for checking results:

If we use a high resolution, those plots are not showing much, thats why they are only showing the first 10000 values.
** Plot real and imaginary part of the created n_L matrix:

Real part is blue, imaginary is red.

#+BEGIN_SRC python :results file :tangle no :exports both
  fig = plt.figure()
  plt.plot(np.real(n_L[:10000]), c='b')
  plt.plot(np.imag(n_L[:10000]), c="r")
  plt.savefig('n_L.png')
  './n_L.png'

#+END_SRC

#+RESULTS:
[[file:./n_L.png]]

** Plot real and imaginary part of \rho_L

#+BEGIN_SRC python :results file :tangle no :exports both 
  fig = plt.figure()
  plt.plot(np.real(rho_L), c='b')
  plt.plot(np.imag(rho_L), c='r')
  plt.savefig('rho_L.png')
  "./rho_L.png"
#+END_SRC

#+RESULTS:
[[file:./rho_L.png]]

** Plot of the difference between \rho_L and the given \rho and determined minimum:

The difference is shown in blue, the red lines show the minimum.

#+BEGIN_SRC python :results file :tangle no :exports both 
  fig = plt.figure()
  plt.axvline(idx, c='r')
  plt.axhline(minimum, c='r')
  plt.plot(diff[:idx+10000])
  plt.savefig('diff.png')
  "./diff.png"
#+END_SRC

#+RESULTS:
[[file:./diff.png]]

** Plot refractive angle phi_L and n_L:

n_L is shown in green, real part of phi_L in blue, imaginary in red. 
A relation between these should be visible.

#+BEGIN_SRC python :results file :tangle no :exports both 
  fig = plt.figure()
  plt.plot(np.real(phi_L[:5000]), 'b')
  plt.plot(np.imag(phi_L[:5000]), 'r')
  plt.plot(np.real(n_L[:5000]), c='g')
  plt.savefig('phi_L.png')
  "phi_L.png"
#+END_SRC

#+RESULTS:
[[file:phi_L.png]]


* Testing: 

Testing with constant n_L, phi_i at i=0
  #+BEGIN_SRC python :results table :export none
   [("n_L[0]",n_L[0]),("phi_i",phi_i)]
  #+END_SRC

  #+RESULTS:
  | n_L[0] |          (1+0.01j) |
  | phi_i  | 1.2217304763960306 |

** snell():

#+BEGIN_SRC python :results value :export both
  phi_Ltest = snell(phi_i, n_air, n_L[0])
  phi_Ltest
#+END_SRC

#+RESULTS:
| 1.2204293562148987-0.02737077533152331j |
should be: (1.220429-0.02737074 i)

#+BEGIN_SRC python :export both
("n_S",n_S)
#+END_SRC

#+RESULTS:
| n_S | (2.6726+3.0375j) |

#+BEGIN_SRC python :exports both :results value
  phi_Stest = snell(1.220429-0.0273775j,n_L[0],n_S)
  phi_Stest
#+END_SRC

#+RESULTS:
| 0.15167146706201226-0.1754944190504326j |
should be: (0.151671-0.175494i)

  
  
** fresnel():

  # Fresnel equations:
  # air/layer:
  rs_al, rp_al = fresnel(n_air, phi_i, n_L, phi_L)
  # layer/substrate:
  rs_ls, rp_ls = fresnel(n_L, phi_L, n_S, phi_S)

#+BEGIN_SRC python :export both :results value
  rs_altest, rp_altest = fresnel(n_air, phi_i, n_L[0], phi_Ltest)
  rs_altest
#+END_SRC

#+RESULTS:
| -0.0033999254327574746-0.04239424576449757j |
should be: (-0.003398-0.04239i)
#+BEGIN_SRC python :export both :results value
rp_altest
#+END_SRC

#+RESULTS:
| -0.0033473348657266995-0.03238064466694647j |
should be: 

#+BEGIN_SRC python :export both :results value
  rs_lstest, rp_lstest = fresnel(n_L[0], phi_Ltest, n_S, phi_Stest)
  rs_lstest
#+END_SRC

#+RESULTS:
| -0.8814233130816392-0.10701715470726722j |

#+BEGIN_SRC python
rp_lstest
#+END_SRC

#+RESULTS:
| 0.1977200465339483+0.4600671830365366j |

** calc_rho():

rho_L = calc_rho(rs_al, rp_al, rs_ls, rp_ls, d_L, n_L, lambda_vac)
 Just copied this from above with beta returned 
#+BEGIN_SRC python :results silent :tangle yes
  def calc_rhotest(rs_al, rp_al, rs_ls, rp_ls, d, n, phi, lambda_vac):
      beta = 2 * np.pi * d * n * np.cos(phi) / lambda_vac
      rp_L = (rp_al + rp_ls * np.exp(-2*1j*beta)) / (1 + rp_al * rp_ls * np.exp(-2 * 1j * beta))
      rs_L = (rs_al + rs_ls * np.exp(-2*1j*beta)) / (1 + rs_al * rs_ls * np.exp(-2 * 1j * beta))
      rho_L = rp_L / rs_L
      return rho_L, beta
#+END_SRC

  #+BEGIN_SRC python :export both :results value  
    rhotest, betatest = calc_rhotest(rs_altest, rp_altest, rs_lstest, rp_lstest, 300, n_L[0], phi_Ltest, lambda_vac)
    betatest
  #+END_SRC

  #+RESULTS:
  | 2.1558486861854713+0.18312239563626334j |
  should be: 2.1558487+0.18312240i
  
 #+BEGIN_SRC python :export both :results value
   rhotest 
 #+END_SRC 

 #+RESULTS:
 | -0.2562015784819146-0.456331697173584j |

*  bibliography:forschungspraktikum.bib
