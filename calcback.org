#+TITLE: Calcback
#+AUTHOR: Nikolai Weidt
#+Email: weidtn@gmail.com
#+PROPERTY: header-args:python :session *python*
#+PROPERTY: cache yes
#+PROPERTY: latexpreview inlineimages
#+PROPERTY: attr_html:width 600px
#+options: :toc nil
#+latex_header: \usepackage{float}


* What is this?
I'm coding a program to get the complex refractive index $n = n * ik$ from the ellipsometric parameters $\Delta$ and $\Psi$ I got from a simulation.
The result for 300nm SiO_2 should look like this:

#+CAPTION: Refractive index should look like this
#+NAME: sio2
#+attr_latex: :width 0.5\textwidth
#+attr_html: :width 500
#+attr_org: :width 500
[[./RefractiveIndexSiO2.png]]

* Imports:
#+BEGIN_SRC python :results output silent
  import numpy as np
  import matplotlib
  matplotlib.use('Agg')
  import matplotlib.pyplot as plt
#+END_SRC 

* Defining some variables:
Defining some variables for later use:

#+BEGIN_SRC python :results output silent
  CSVFILE = "head300nmSiO2.csv" # head = only 10 rows of data
  phi_i = 70 * np.pi / 180 # converting incident angle from deg (first number) to rad
  d_L = 300 # thickness of layer in nm
  n_air = 1 # refractive index of air
  rerange = 5 # upper limit for real part 
  imrange = 5 # upper limit for imaginary part
  i = 1 # only look at one row
#+END_SRC

* Read .csv-file:
Read the values into a two dimensional numpy array as [[lambda,Psi,Delta,n_S,k_S],...] (Skip columns 3 and 4)
  
#+BEGIN_SRC python :results output silent
csv = np.loadtxt(CSVFILE, usecols=(0,1,2,5,6),  delimiter=",", skiprows=1)
#+END_SRC

:DEBUG:
The array looks like this:
#+BEGIN_SRC python :results output table :exports both
print(csv)
#+END_SRC
#+RESULTS:
| 300 |  55.2217535 |  84.37228319 | 2.6726 | 3.0375 |
| 303 | 50.11187439 |   93.3085011 | 2.7346 | 3.0381 |
| 306 | 46.35824553 |  98.43681392 | 2.7967 | 3.0368 |
| 309 | 43.50539341 | 101.18051798 | 2.8588 | 3.0334 |
| 312 | 41.29392865 | 102.19236832 | 2.9206 | 3.0279 |
| 315 | 39.48751217 |    101.93002 | 2.9822 | 3.0205 |
| 318 | 37.90308303 | 100.64846104 | 3.0435 | 3.0109 |
| 321 | 36.47640803 |  98.54577151 | 3.1042 | 2.9994 |
| 324 | 35.12615859 |  95.72242205 | 3.1644 | 2.9858 |

* Calculate \rho
** Create a matrix containing every possible refractive index (n+ik):
#+BEGIN_SRC python :results silent
  lsp_re = np.linspace(0.1, rerange, 1001)
  lsp_im = np.linspace(0.1, imrange, 101)
  re, im = np.meshgrid (lsp_re, lsp_im, copy=False)
  n_L = 1j * im + re
  n_L = n_L.flatten() # create an onedimensional array from matrix
#+END_SRC

:DEBUG:
This gives the following matrix:
#+BEGIN_SRC python :results output :exports both :tangle no
print(n_L)
#+END_SRC

#+RESULTS:
: [0.1   +0.1j 0.1049+0.1j 0.1098+0.1j ... 4.9902+5.j  4.9951+5.j
:  5.    +5.j ]

:END:

** Calculate \rho: 
*** First we define some functions:
**** Snell's Law to calculate the refractive angles:
Phi is the incident angle for the layer, n1 and n2 are refractive indices of first and second medium. Returns the angle of refraction.

#+CAPTION: Snell's Law
#+NAME: fig:snell
#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 500
#+ATTR_LATEX: :width 0.5\textwidth
#+ATTR_LATEX: :placement [H]
[[./snell.jpg]]
#+BEGIN_SRC python :results silent
  def snell(phi, n1, n2):
      phi_ref = np.arcsin((np.sin(phi) * n1) / n2)
      return phi_ref
#+END_SRC   


**** Calculate r_p and r_s with Fresnel equations:
#+BEGIN_SRC python :results silent
  def fresnel(n1, phi1, n2, phi2):
      """Takes refractive indices and angles of two layers to calculate the amplitude reflection coefficients"""
      rs = (n1 * np.cos(phi1) - n2 * np.cos(phi2)) / (n1 * np.cos(phi1) + n2 * np.cos(phi2))
      rp = (n2 * np.cos(phi1) - n1 * np.cos(phi2)) / (n2 * np.cos(phi1) + n1 * np.cos(phi2))
      return rs, rp
#+END_SRC


**** Calculate \rho for the layer with eq. 5.2 in Spectroscopic Ellipsometry citenum:fujiwara2009spectroscopic:
#+BEGIN_SRC python :results silent
  def calc_rho(rs_al, rp_al, rs_ls, rp_ls, d_L, n_L, lambda_vac):
      beta = 2 * np.pi * d_L * n_L * np.cos(phi_L) / lambda_vac
      rp_L = (rp_al + rp_ls * np.exp(-2*1j*beta)) / (1 + rp_al * rp_ls * np.exp(-2 * 1j * beta))
      rs_L = (rs_al + rs_ls * np.exp(-2*1j*beta)) / (1 + rs_al * rs_ls * np.exp(-2 * 1j * beta))
      rho = rp_L / rs_L
      return rho
#+END_SRC


*** Then we call these functions one after another to calculate \rho:
Get refractive index of the substrate (n_S) and lambda from the csv:
#+BEGIN_SRC python :results output silent
  n_S = (csv[i, 3] + 1j * csv[i, 4])
  lambda_vac = csv[i, 0]
#+END_SRC

Then call the above defined functions
#+BEGIN_SRC python :results output silent
  phi_L = snell(phi_i, n_air, n_L)
  phi_S = snell(phi_L, n_L, n_S)
  # Fresnel equations:
  # air/layer:
  rs_al, rp_al = fresnel(n_air, phi_i, n_L, phi_L)
  # layer/substrate:
  rs_ls, rp_ls = fresnel(n_L, phi_L, n_S, phi_S)

  rho_L = calc_rho(rs_al, rp_al, rs_ls, rp_ls, d_L, n_L, lambda_vac)
#+END_SRC

:DEBUG:
Debug:
#+BEGIN_SRC python :results output :tangle no :exports no 
  # print("lambda = %.1f nm" % lambda_vac)
  # print("phi_L", phi_L)
  # print("phi_S", phi_S)
  # print("rs_al", rs_al)
  # print("rp_al", rp_al)
  # print("rs_ls", rs_ls)
  # print("rp_ls", rp_ls)
  print("rho_L =", rho_L)
#+END_SRC

#+RESULTS:
: rho_L = [ 0.77162186+0.64751645j  0.77213475+0.64747272j  0.77265972+0.64741577j
:  ... -1.3933717 +0.83923359j -1.393898  +0.83861153j
:  -1.39442292+0.83798908j]

:END:


*** Identify the best fitting rho with \rho = tan(\psi) * e^i\Delta :
#+BEGIN_SRC python :results output
  # psi is in our csv-file at index 1, delta at index 2 at row "i" for lambda
  psi = csv[i][1]
  delta = csv[i][2]
  rho = np.tan(psi) * np.exp(1j * delta)
  diff = abs(rho - rho_L)  # magnitude of complex number
  idx = np.argmin(diff)  # index of the minimum
  minimum = diff[idx]
  n = n_L[idx]
  print("This gives us the refractive index n_L = ", n)
#+END_SRC

#+RESULTS:
: This gives us the refractive index n_L =  (1.2172000000000003+0.1j)



bibliographystyle:unsrt
bibliography:forschungspraktikum.bib
